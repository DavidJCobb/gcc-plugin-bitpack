
# To-do

## `lu-bitpack`

### BLUF

* Our functions generate properly but don't do anything.
  * We zero-fill the buffer before saving, so we can tell whether the save function did anything.
  * We `memset` the state structs to 0x7E (`'~'`) one sector at a time, before reading each sector, so we can tell whether the read function did anything.


#### details

Reading fields' serialization options:

* Move parsing and handling of field attributes from `data_member.(h|cpp)` to `bitpacking/data_options.(h|cpp)`.
* Delete `struct.(h|cpp)` and `data_member.(h|cpp)`.
* Update `bitpacking::data_options::computed` to pay attention to the `bitpacking::data_options::requested::as_string` member.
* Add a field attribute indicating that a field should be serialized as an opaque buffer.
  * Update `bitpacking::data_options::requested` to check for and react to the attribute.
* Finish `bitpacking::data_options::requested` generally.
  * `lu_bitpack_inherit`
  * Throw `std::runtime_error` on invalid. If possible, use a custom exception and find a way to report source info.
* Finish `bitpacking::data_options::computed` generally.
* Delete `bitpack_options.(h|cpp)`, as we'll be using `bitpacking::data_options::requested` in its place.

Dealing with serializable objects:

* Currently, our `sector_functions_generator` is responsible for generating all per-sector serialization functions *and* all whole-struct serialization functions.
  * Finish replacing `sector_functions_generator::target` with `sector_functions_generator::value_pair`.
  * Implement member functions of `sector_functions_generator::value_pair`.

`sector_functions_generator` relies on `codegen::structure` and `codegen::structure_member`. We want to refine both of these classes.

Currently, there are multiple places where `sector_functions_generator` needs to be able to take an arbitrary `gw::value` and produce the appropriate serialization call: whole-struct, whole-primitive, or array-slice (including whole-array). These include but are not limited to:

* When generating whole-struct functions, i.e. when generating code to serialize whole structs. These functions are generated by `sector_functions_generator::get_or_create_whole_struct_functions`.
* When generating code to serialize an array slice. This is done in `sector_functions_generator::_serialize_object`.
* Certain parts of the overall serialization loop in `sector_functions_generator::run`.

I want to be able to define a function `sector_functions_generator::_serialize_object` that "just works:" give it the `gw::value`s of the bitstream-state-pointer and the to-be-serialized object, and it'll call out to the appropriate other functions to serialize a struct, array, or primitive. This is mostly achievable...

...except for a defect in `_serialize_array`. The `_serialize_*` functions rely on an info pointer -- either a `codegen::structure&` or `codegen::structure_member&` -- to know what to serialize. The problem is that we don't create nested `codegen::structure_member`s for nested arrays; they're stored "flat," which means that when we recurse to generate for-loops for nested arrays, we don't know the right array extent to use (we can't get it off of `codegen::structure_member::decl`). This gives us two options:

* Rummage through the data for the `gw::value`s we're working with.
  * If they're a `FIELD_DECL`, then pull the array extent directly from its type.
  * If instead they're an `ARRAY_REF`, then track how many array extents we're serializing until we reach a `FIELD_DECL` or a non-`ARRAY_REF`.
    * But what if we hit something like `foo[3].bar[4][5]`?
      * And also, I'm not sure whether `sector_functions_generator::_info_for_target` can even properly retrieve the appropriate `structure*` or `structure_member*` for nested array values or anything liek that.
* Recursively generate nested `codegen::structure_member`s for nested arrays.

Like, basically, the entire codebase is halfway between three different rewrites. I should probably copy everything *not* related to serialization, bitpacking, the attributes, the pragmas, etc., into a new folder hierarchy and then start from scratch, using those salvageable parts of the old work to guide the new.

---

I attempted to design a replacement for both `codegen::structure` and `codegen::structure_member`, `codegen::serializable_object`, motivated by the fact that we should handle arrays and structs more-or-less uniformly: both should be treated as containers that we need to iterate over in some fashion. However, using `codegen::serializable_object` to represent both a struct type (regardless of context) and a struct member basically erases the distinction between a `RECORD_TYPE` and a `FIELD_DECL`, and this is causing more problems (organizational, logistical, mental model) than it's solving. Whatever improvement I make needs to maintain that distinction; we should delete `serializable_object`.

### general

Currently writing the bitpack logic in `bitpacking/sctor_functions_generator.(h|cpp)`.

**Old bitpacking approach:**

This is the approach I used to generate C source code from XML struct definitions.

* Index all types and their members' bitpacking options (load XML definitions)
* For each struct type, generate a function that will serialize an entire instance of that type.
* Create a list of `serialization_item` instances (the "item list") &mdash; one for each top-level struct to serialize.
  * Each `serialization_item` consists of a pointer to an indexed struct, a pointer to an indexed struct member, a list of zero or more array indices, and a string representing the fully-qualified path to the described member.
* For each item in the item list:
  * Try to fit the item into the current sector. (In particular, if it's a struct type or an array thereof, then we invoke one of the functions we generated earlier to serialize the thing whole.)
  * If the item doesn't fit, then try to "expand" it.
    * If expansion is possible (i.e. if the item is a struct or array), then it will produce multiple `serialization_item` instances; replace the current item with those (splicing them into the item list), and then retry from the first of them.
      * For example, given a member `int foo[3][2][3]`, expanding `foo` produces `foo[0]`, `foo[1]`, and `foo[2]`; and expanding `foo[0]` produces `foo[0][0]` and `foo[0][1]`.
      * Similarly, given a member `struct foo_type { int a; int b; } c[2]`, expanding `c[0]` produces `c[0].a` and `c[0].b`. Both of these serialization items refer to the `foo_type` struct and its members `a` and `b`; the only way to know that we got here from `c[0]` is via the path string (e.g. `"c[0].a"`).
    * If expansion is not possible, then start a new sector.

As you can imagine, the use of string paths here complicates using this approach in our GCC plug-in.

**New bitpacking approach:**

* Start the zeroth sector.
* For each top-level variable to serialize:
  * **[A]** For each member of the current variable:
    * If the member is a struct, then...
      * If the member can fit entirely in the current sector, then bitpack it whole.
      * Else if the member can't fit, then...
        * Recursively execute **[A]** treating this member as the new current variable.
    * Else if the member is a non-struct or array of structs, then...
      * If the member can fit entirely in the current sector, then bitpack it whole.
      * Else if the member can't fit, then...
        * If the member isn't an array, then start a new sector, and then recursively execute **[A]** treating the member as the new current variable.
        * Else if the member is an array...
          * While there are any array elements left to serialize:
            * Compute the number of elements *n* that can fit in the current sector's available space.
            * Bitpack the next *n* elements.
            * Recursively execute **[A]** treating the next element as the new current variable. The effect of this will be to split the element across sector boundaries if indeed it can be split, and start a new sector either way.

Rather than indexing the bitpacking options and data for all structs in advance, we instead extract those options from struct types as those types are encountered, caching them for fast retrieval should we encounter more instances of the same struct type later.

Similarly, we don't split structs across sector boundaries (with the `serialization_item` lists) in advance of code generation. Instead, we perform the sector splits as we generate code.

In essence, we've folded three passes into one: we index bitpacking options and handle sector splitting as we generate the code.

### Details

The process is managed by a `sector_functions_generator` object. The object generates the per-sector read and save functions alongside each other, which among other things means that instead of operating directly in terms of GCC wrappers (e.g. `gw::value`), it has to use bifurcated data (e.g. `sector_functions_generator::target`, which stores one `value` for the "read" half and one value for the "save" half).

### To-do

In short: the overall "traversal" algorithm for `sector_functions_generator` as documented above, I think, is fine; but the functions that it calls to actually generate bitstream read/write code (for whole values and for array slices) are yet to be defined. I need to figure those out.

Probably the easiest thing to start with would be the case of serializing a whole struct of type `T`: we need to lookup (or generate and cache, if they've not yet been created) functions that serialize an entire `T` (i.e. `void __read(lu_BitstreamState*, T*)` and `void __save(lu_BitstreamState*, const T*)`) and invoke them. Then comes the case of non-struct non-array values, wherein we use a variety of different functions depending on the type (bool type, specific integral types, strings). Lastly would be the case of serializing an entire array; this one's tricky because we have to be able to recursively construct for-loops to handle the case of arrays-of-arrays.

* Probably it'd be best to design the "whole struct" and "primitive" cases so that they just return an `expr`, and where we insert that is our business. Then, we can have the "whole array" case return an `expr` as well. Then, we can have the top-level caller -- the "serialize whole value" function -- actually insert the expr somewhere; and at the same time that we do that, we can make the "whole array" case recursive.
  
  Of course, we'll need both "read" and "save" functions (i.e. "generate read-whole-struct call" and "generate save-whole-struct-call" helpers; and "generate read-whole-array call" and "generate read-primitive call" and so on).

After that, we'll need to figure out the "array slice" case. This needs to behave very similarly: it gets called when we know to a certainty that that slice of the array will fit into the current sector. Honestly, if we do the "whole value" case per the bulleted note above, then we could have the "array slice" case just generate and append the outermost for-loop as appropriate.

* There's no way to communicate global bitpacking options (e.g. sector size, sector count, sector layouts) to the `sector_functions_generator`.
* We need code to generate whole-struct bitstream-read and bitstream-write functions. They should be generated on first use.
* When dealing with an array of arrays, `sector_functions_generator::in_progress_func_pair::serialize_array_slice` needs to be able to run recursively.
* When dealing with an array of structs, `sector_functions_generator::in_progress_func_pair::serialize_array_slice` needs code to generate the appropriate calls to the whole-struct functions we generated.
* `sector_functions_generator::in_progress_func_pair::serialize_entire` is unimplemented.
* `sector_functions_generator::in_progress_sector` needs a constructor which creates the initial read/save funcs and their root blocks.
* `sector_functions_generator::in_progress_sector::next` needs to create the next set of read/save funcs and their root blocks.
* Once we have the `sector_functions_generator` working on a basic level, we'll then want to implement the "layout" pragma, which gives you "fuzzy" control over which structs go in which sectors (i.e. being able to say, "*this* struct right here should get its own sector").
  * Perhaps we should implement an alternate syntax when specifying the variables to serialize, e.g. `( a | b c | d )` to indicate, for example, that after `a` we should skip to the start of the next sector, and after `c` we should skip to the next sector, such that `b` and `c` can potentially share a sector, but `a` never shares a sector with `b`, nor `c` with `d`.

## outdated; review

* `handle_kv_string` should throw an exception with detailed error information for its caller to report
* Custom pragma to define a set of `HeritableOptions`, and a singleton to store them
  * Error on redefinition
  * Error on internally inconsistent options (e.g. string with a max integral value)
* If `lu_bitpack_string` specifies a string length, it should error if the deepest rank of the char array it's used on is not of that length (e.g. if the length is 7, `char foo[3][7]` should be accepted and `char foo[3][5]` should fail).
* Finish implementing `lu_bitpack_inherit` for having a struct member use a set of heritable options
* Finish implementing `lu_bitpack_funcs` (parsing only)
* Add an attribute that annotates a struct or a struct member as being `memcpy`'d into the bitpacked stream. (Actually, it'd be bitpacked one byte at a time, so as to avoid padding bits around the nenber; but the member itself would be treated as an opaque blob of data.)
* Add an attribute that annotates a struct member with a default value. This should be written into any bitpack format XML we generate (so that upgrade tools know what to set the member to), and if the member is marked as do-not-serialize, then its value should be set to the default when reading bitpacked data to memory.
* Implement annotation and processing of unions
  * If a union's members are all structs, and each struct's first member is of the same type, alignment, and name, then allow that member to be used as the union's tag (but require that the user specify this, and require that they indicate which values map to which inner structs).
* Add pragmas to set optional top-level serialization params.
  * Sector size
  * Max sector count
  * Max total size
  * Version number location (start of sector 0; start of all sectors; no version number)
* Add a pragma which allows you to specify that a given typedef (e.g. `BOOL`, `bool8`, etc.) always refers to a bool and should by default serialize as a single bit based on whether its value is non-zero. Try to catch nested typedefs (e.g. `typedef BOOL smeckledorfed; smeckledorfed spongebob = TRUE;`) in the struct-/union-handling logic.
* Add pragmas to specify the names of functions that can serialize various lowest-level data types, as well as a pragma to specify a "state" data type that these functions should take as an argument.
  * "Read" functions for integrals should take a state pointer and a bitcount, and return a result. It should be possible to specify different functions for different in-memory sizes (i.e. 8-bit, 16-bit, 32-bit). If the largest serialized value has an *n*-bit in-memory type, you should not need a function that can handle larger in-memory sizes.
  * "Read" functions for strings should take a state pointer, a destination string `uint8_t` pointer, and a max length. There should be separate functions for strings that require an in-memory null terminator and strings that do not.
  * "Read" functions for bools should take a state pointer.
  * "Write" functions for integrals should take a state pointer, value, and bitcount.
  * "Write" functions for strings should take a state pointer, source string `uint8_t` pointer, and a max length. There should be separate functions for strings that require an in-memory null terminator and strings that do not.
  * "Write" functions for bools should take a state pointer and a value.
  * "Read" and "write" functions for arbitrary buffers should take the same basic arguments as strings, but using void pointers rather than `uint8_t` pointers. These functions should only be necessary if any structs or struct members are annotated as being directly `memcpy`'d.
* Add a pragma which generates the code to serialize a given variable (e.g. a global instance of some struct) into the bitpacked data, continuing from where serialization left off (or starting at the beginning of sector 0 if it's the first thing we're generating). For now, we only care about serializnig globals, so reading/writing directly from/to them is fine.
  * When serialization is divided into sectors, there should be a general entry point that takes a sector index and a source/destination buffer. When serialization is not divided into sectors, just take a buffer.
  * Start with the basic data types first; then implement the pre-pack and post-unpack function option.
* Add a pragma which forces serialization to skip to the start of the next sector, leaving any remaining space in the current sector unused.